#!/usr/bin/env python
# -*- coding: UTF-8 -*-
'''
@Author  ：wma
@Date    ：2022/8/25 2:17 PM 
@process    :
@change :
'''
'''
https://blog.csdn.net/python_tian/article/details/122036783

一、示例 
待排序序列是（5，1，4，2，8）从小到大排序
1、第一轮排序：
    第一次比较：5，1，4，2，8   ----->   1，5，4，2，8
    第二次比较：1，5，4，2，8   ----->   1，4，5，2，8
    第三次比较：1，4，5，2，8   ----->   1，4，2，5，8
    第四次比较：1，4，2，5，8   ----->   1，4，2，5，8
2、第二轮排序：
    第一次比较：1，4，2，5，8   ----->   1，4，2，5，8
    第二次比较：1，4，2，5，8   ----->   1，2，4，5，8
    第三次比较：1，2，4，5，8   ----->   1，2，4，5，8
3、第三轮排序：
    第一次比较：1，2，4，5，8   ----->   1，2，4，5，8
    第二次比较：1，2，4，5，8   ----->   1，2，4，5，8
4、第四轮排序：
    第一次比较：1，2，4，5，8   ----->   1，2，4，5，8
5、第五轮排序，由于待排序序列中仅剩 1 个元素，无论再进行相邻元素的比较，因此直接将其并入已排序序列中，此时的序列就认定为已排序好的序列
二、冒泡排序的实现代码(python)
1、第一种
    def mao_pao(num_list):
        num_len = len(num_list)
        # 控制循环的次数
        for j in range(num_len): # 添加标记位 用于优化(如果没有交换表示有序,结束循环)
            sign = False 
            # 内循环每次将最大值放在最右边
            for i in range(num_len - 1 - j):
                if a[i] > a[i+1]:
                    a[i], a[i+1] = a[i+1], a[i]
                    sign = True
                    # 如果没有交换说明列表已经有序，结束循环
            if not sign:
            break
    if __name__ == '__main__':
        a = [1, 3, 4, 2, 6, 9, 12, 3, 22]
        mao_pao(a)
        print(a)
2、第二种
    list1 = [5, 1, 4, 8, 2]
    length = len(list1)
    for i in range(length):
        for j in range(length-i-1):
            if list1[j] > list1[j + 1]:
                    list1[j], list1[j + 1] = list1[j + 1], list1[j]
    print(list1)

三、时间复杂度和空间复杂度
我们按两种情况来分:
如果我们的顺序是正序，即最理想的一种情况，只需走一遍即可完成排序,所需的比较次数C和记录移动次数M均达到最小值，
即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。
如果很不幸我们的数据是反序的，则需要进行n-1趟排序。
每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：（等差数列求和）

时间复杂度:

冒泡排序的最好时间复杂度为：O(n)，示例[1,2,3,4,5]
最差的时间复杂度为: O(n2）示例: [5,4,3,2,1]

'''
