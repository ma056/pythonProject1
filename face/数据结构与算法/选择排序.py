#!/usr/bin/env python
# -*- coding: UTF-8 -*-
'''
@Author  ：wma
@Date    ：2022/8/25 3:13 PM 
@process    :
@change :
'''
'''
https://blog.csdn.net/python_tian/article/details/122070428
一、选择排序(selection sort)
选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，所以称为：选择排序

二、选择排序和冒泡排序对比
选择排序是一种简单直观的排序算法。它与冒泡排序很相似，都是比较 n-1 轮，每轮都是比较 n–1–i 次，每轮找出一个最大值或最小值。
只不过，冒泡排序是将每轮找出的最值放到最右边，而选择排序是将每轮找出的最值放到最左边。
并且在算法上，冒泡排序是将相邻的数进行逐个比较，以从小到大排序为例，只要前面的比后面的大，就互换这两个数，直到最后将最大的数“浮”到最右边，如此依次循环。
而选择排序是先保存第一个元素的下标，然后后面所有的数依次与第一个元素相比，如果遇到更小的，则记录更小的那个数的下标，然后后面所有的数都依次与那个更小的数比较，直到最后将最小的数的下标找出来，然后再将这个数放到最左边，即与下标为 0 的数互换。
如果最小的数的下标就是 0 那么就不用互换。
所以，选择排序算法是先判断最小的数的下标是不是 0，如果不是则说明最小的数不是第一个元素，则将这个数与第一个元素互换位置，这样一轮下来最小的那个数就被找到并放到了最左边。
在第二轮同样先保存新序列第二个元素的下标，后面所有的数依次与第二个元素相比较，如果遇到更小的则记录更小的那个数的下标，然后后面所有的数都依次与那个更小的数比较，直到最后又找到一个最小的，此时这个最小的在整个序列中是“第二小”。
然后再判断这个数的下标是否等于 1，如果不等于 1 说明“第二小”的那个数不是第二个元素，则将这个数与第二个元素互换位置，这样第二轮下来就找到了“第二小”的那个数，并将它放到了第二个位置。如此循环，直到整个序列实现从小到大排序。
如果是从大到小排序，那么就记录大的那个数的下标，每一轮找出一个最大的数放到左边。
从上面的分析可以看出，选择排序和冒泡排序的另一个不同点是，冒泡排序只要遇到前面比后面大的就互换，而选择排序是比较一轮才互换一次，而且如果本轮中最小的就是最左边那个数则不用互换。
所以从这个角度看，选择排序比冒泡排序的效率要高。而且通过上面对选择排序的分析发现，从逻辑上讲，与冒泡排序相比，选择排序更符合人的思维。

三、分析
待排序：56，12，80，91，20
第一遍循环：从下标1的位置即56开始，找出关键值最喜哦啊的记录12，同下标为0的关键字56交换位置
12，56，80，91，20
第二次循环：从下标2的位置即56开始，找出最小值20，同下标为2的关键字56互换位置
12，20，80，91，56
第三次循环：从下标3的位置即80开始，找出最小值56，同下标为3的关键字80互换位置
12，20，56，91，80
第四次循环：从下标4的位置即91开始，找出最小值80，同下标为4的关键字91互换位置
12，20，56，80，91

四、代码
1、第一种
    def selection_sort(num_list):
        length = len(num_list)
        if length <= 1:
            return num_list
    
        for j in range(length):
            # 假设第一个元素为最小元素
            min_num_index = j
            
            # 遍历未排序区域元素，以此和未排序区域的第一个元素做对比
            for i in range(j+1, length):
                if num_list[i] < num_list[min_num_index]:
                    min_num_index = i
             
            # 交换位置
            num_list[min_num_index], num_list[j] = num_list[j], num_list[min_num_index]
    
        return num_list
    
    
    if __name__ == '__main__':
        a = [1, 3, 2, 6, 4, 12, 33, 5, 25]
        print(selection_sort(a))
2、第二种
    list1 = [3, 2, 1, 4, 6, 5]
    length = len(list1)
    for i in range(length):
        min = i
        for j in range(i + 1, length):
            if list1[j] < list1[min]:
                min = j
                # list1[min], list1[j] = list1[j], list1[min]
        list1[min], list1[i] = list1[i], list1[min]
    print(list1)
    
五、时间复杂度和空间复杂度
空间复杂度：只需要常数个辅助单元，所以空间复杂度为O(1)
时间复杂度：我们看到选择排序同样是双层循环n*(n-1))，所以时间复杂度也为：O(n^2)
稳定性：因为存在任意位置的两个元素交换，比如[5, 8, 5, 2]，第一个5会和2交换位置，所以改变了两个5原来的相对顺序，所以为不稳定排序。
是否为原地排序: 是原地排序
'''