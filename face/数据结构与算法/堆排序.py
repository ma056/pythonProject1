#!/usr/bin/env python
# -*- coding: UTF-8 -*-
'''
@Author  ：wma
@Date    ：2022/8/31 3:17 PM 
@process    :
@change :
'''
'''
https://www.zybuluo.com/listenviolet/note/1399285#7-%E5%A0%86%E6%8E%92%E5%BA%8F
堆排序：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点
7.1 数组与二叉树
堆是一个近似完全二叉树的结构，并同时满足堆积的性质：
大顶堆满足：子结点的键值或索引总是小于它的父节点；
小顶堆满足：子结点的键值或索引总是大于它的父节点。
数组索引与二叉树中节点的关系：
当前node的值在数组中的索引为 i
其左孩子节点对应数组索引为 2*i+1
其右孩子节点对应数组索引为 2*i+2
其父节点对应数组索引为 (i-1)/2
　　　4
　　/ 　　\
　 5　　　 3
　/　\ 　　/
2　　6 　1

7.2 堆的创建（初始化）
给定一棵二叉树，将其调整为堆有自上而下调整方式，以使其满足最大堆/最小堆的性质。

7.2.1 算法描述(例子：调整为小顶堆)
所有的叶子节点均可以看作已经调整为最小堆的结构；故从第一个有孩子节点的节点开始向前遍历调整，直到遍历调整根结点后停止；
若当前节点node(i)的值不大于其左右孩子节点的值，则继续遍历前一个节点(即节点序号 i - 1)；
若当前节点node(i)的值大于其孩子节点的值，则选择值最小的孩子节点与该节点交换，直至调整到以node(i)为根结点的子树满足最小堆的性质；继续遍历前一个节点node(i-1)。
7.2.2 例子
　　　98
　　/ 　　\
　 86　　　 68
　/　\ 　　/
58　　42 42*

1.第一个非叶子节点为68，68 > 42*，故交换
　　　98
　　/ 　　\
　 86　　　 42*
　/　\ 　　/
58　　42 68

2.继续向前遍历，到节点86；86 > 58 > 42; 将86与最小的孩子节点42交换
　　　98
　　/ 　　\
　 42　　　 42*
　/　\ 　　/
58　　86 68

3.继续向前遍历，到根结点98；98 > 42 = 42*; 将98与42交换；
　　　42
　　/ 　　\
　 98　　　 42*
　/　\ 　　/
58　　86 68

4.将以98为根结点的子树调整为最小堆; 98 > 86 > 58; 将98与58交换;调整完毕。
　　　42
　　/ 　　\
　 58　　　42*
　/　\ 　　/
98　　86 68

7.2.3 代码实现
自上而下调整子树为最小堆:(见算法描述3)
# Adjust from top to bottom
# a: the arr
# i: adjust from node i
# n: the total number of nodes in heap
# j: the child of i
def MinHeapFixdown(a, i, n):
    temp = a[i]
    j = 2 * i + 1
    while j < n:
        if j + 1 < n and a[j + 1] < a[j]: # find the min of left and right child
            j += 1
        if a[j] < temp:
            a[i] = a[j]
            i = j
            j = 2 * i + 1
        else: break
    a[i] = temp

7.3 堆中元素的删除 与 堆排序
在堆排序中，根结点的值为当前堆的最小值，如果以此取出根结点的值，并将剩余元素重新调整为最小堆，即可将原数组元素由小到大依次取出。
这里就涉及到如何取出根节点的值，并调整剩余元素为最小堆的算法实现。
7.3.1 算法描述
取出最小堆的根的值；将当前最小堆的根的值与最后一个元素交换；
利用7.1.2中"自上而下调整子树为最小堆"的方法，将前n - 1 个元素构成的树重新调整为最小堆结构。
7.3.2 例子
　　　42
　　/ 　　\
　 58　　　42*
　/　\ 　　/
98　　86 68
1. 取出根结点的值，加入到已排序的数组arr中，并交换42与最后一个节点68的值。
　　　68
　　/ 　　\
　 58　　　42*
　/　\ 　　/
98　　86 42
arr = [42]
2. 此时认为42已被删除（被删除元素用斜体标注）；对剩余的前5个元素进行调整，自上而下的调整为最小堆；
　　　42*
　　/ 　　\
　 58　　　68
　/　\ 　　/
98　　86 42
arr = [42]
3. 最小堆调整完毕；取出根结点的值42*，加入到已排序的数组arr中，并交换42*与最后一个节点86的值。（注意：42已被删除，最后一个节点为86.）
　　　86
　　/ 　　\
　 58　　　68
　/　\ 　　/
98　　42 42
arr = [42, 42*]
4. 此时认为42*已被删除；对剩余的前4个元素进行调整，自上而下的调整为最小堆；
　　　58
　　/ 　　\
　86　　 68
　/　\ 　　/
98　42* 42
5. 最小堆调整完毕；取出根结点的值58，加入到已排序的数组arr中，并交换58与最后一个节点98的值。
　　　98
　　/ 　　\
　86　　 68
　/　\ 　　/
58　42* 42
arr = [42, 42*, 58]
6. 同理进行调整，直至取出堆中最后一个元素，堆排序完成。arr = [42, 42*, 58, 68, 86, 98]

7.3.3 代码实现
删除当前根结点，并调整剩余元素重新构成最小堆
def MinHeapDeleteNumber(a, n):
    a[0], a[n - 1] = a[n - 1], a[0]
    MinHeapFixdown(a, 0, n - 1)
    
堆排序

def MinHeapSortToDescendArray(a, n):
    for i in range(n - 1, 0, -1):
        a[0], a[i] = a[i], a[0]
        MinHeapFixdown(a, 0, i)
    return a
    
    
7.4 堆中添加元素
7.4.1 算法描述
在一个最小堆中添加新元素，将该元素添加为该树的最后的一个节点。
比较新节点的值与其父节点的值大小；若该节点的值大于父节点的值，则该子结构满足最小堆性质，可以停止调整；若该节点的值小于父节点的值，则交换该结点与其父节点，直到子结构满足最小堆性质。
7.4.2 例子
　　　42
　　/ 　　\
　 58　　　42*
　/　\ 　　/　　＼
98　　86 68　　36

1.添加新元素36到已创建的最小堆中。
2.比较新节点的值36与其父节点的值; 36 < 42 不满足最小堆的性质了，需要进行调整; 交换36和其父节点42*。
　　　42
　　/ 　　\
　 58　　　 36
　/　\ 　　/　　＼
98　　86 68　　42*
3. 比较36与其父节点的值的大小; 36 < 42; 不满足最小堆的性质，需要进行调整; 交换36和其父节点42; 调整完毕。
　　　36
　　/ 　　\
　 58　　　 42
　/　\ 　　/　　＼
98　　86 68　　42*

7.4.3 代码实现
自下而上调整为最小堆

# Adjust from bottom to top
# a: the arr
# i: adjust from node i
# j: the parent of i
def MinHeapFixup(a, i):
    temp = a[i]
    j = (i - 1) // 2          # adjust from the first node which is not leaf
    while j >= 0 and i != 0:  # if the parent > current: current <= parent
        if a[j] < temp:   
            a[i] = a[j]
            i = j
            j = (i - 1) // 2
        else: break
    a[i] = temp
向堆中添加元素

# Add a number to the heap
# a: the arr
# n: the total number of the heap
def MinHeapAddNumber(a, n, number):
    a[n] = number
    MinHeapFixup(a, n)
'''